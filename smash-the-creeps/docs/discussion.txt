# An Analysis of Moddability-as-Accessibility, a Design Pattern to Encourage Access to User Modification for Accessibility Extendibility

Paper by Roger Merryfield

# Abstract

In this paper I propose an alternative philosophy towards meeting gaps in accessibility through gaming, via "Modding as Accessibility". Through encouraging high moddability in software, not only can gaps in accessibility be addressed by the community, but user interfaces can be developed directly by disabled community members, without enforcing a corporate abled power structure imposed onto disabled consultants as seen in professional environments. Instead of being an alternative to more established approaches, "Modding as Accessibility" aims to address inherent issues with closed-source design principles that ultimately lead to reduced control and usability of interfaces.

# Motivation

Accessibility in game design still remains an open question despite commercial success stories, and overall the field struggles with competent implementation. It is highly dependent on developers being invested in accessibility, which can be time consuming, expensive and require extensive research and development. On top of this, games are complicated pieces of software with unique and novel user interface use cases that do not lend themselves easily to known standards, and so much of the field requires extensive research and development offered by disabled consultants, as well as feedback from forums with more established accessibility expectations such as the game discussion and indie game development forum Audiogames.net. Issues with compliance include an unclear set of standards, lack of good case study examples for many genres, lack of public resources on general accessibility concepts beyond basic guidelines, lack of knowledge of disability issues and how to access disability communities, lack of involvement in disability issues, and most concerningly, lack of interest in disability issues. This has lead to the question on how to implement both scalable and easy to implement solutions for both users and developers, regardless of the developer's intent or motivations.

Currently, one of the most influencial individuals within gaming accessibility, Ian Hamilton, insists on a DOM (Document Object Model) based approach to game design, and/or solutions that are heavily integrated with the OS environment. This is directly lifted from his experience in web development and basic UI packages in desktop software, where a DOM may offer some level of structural visibility to a screenreader, even if poorly implemented and ultimately unusable. These programs are designed from the ground up with an expectation for how the DOM should be navigated by a screenreader. However, I have seen many issues with both of these approaches to this problem.

First, to address the insistance on using a DOM, most developers do not work like web developers and do not necessarily build user interfaces through DOM-like structures. Many developers simply use basic draw commands to draw to the screen for their user interfaces, which is completely inaccessible to a DOM. Forcing them to convert to using standardized components will shoo away many developers, including developers experienced in other forms of software development, or those who are in the retro game development community. In the case of retro games, enforcing DOM management is not feasible because of the limited resources available to the device or emulator - and it must be stressed for artistic and sometimes manufacturing reasons that is not acceptable to assert that the game-space should use more memory to compensate. 

More concerningly is that historically, the structure of DOM is violated even within web development, forcing us to question the value of enforcing such a standard in practice. While it makes sense in the world of web development, where every interface is already constructed around the assumption of the presence of a DOM since the very beginning, video games are much more open ended in their potential development and use cases, leading to developers to desire to move outside the expectations of these standards. This is a historical problem that is not exclusive to web development regarding implementation of accessibility in widely distributed user interface models - how do we prevent developers from moving outside of the range of what assistive technologies and users expect?

Video games have unique user interface use cases that are highly specialized and unusual, and not necessarily easy to standardize into a set of expected possibilities, let alone an object model designed to navigate documents, especially as artists and creative programmers push the boundaries of what user interface can be in some parts of the field. Two good examples of why this was a problem historically was the implementation of both Win32 interfaces in the late 1990s in Windows forms applications, and the introduction of Flash onto the internet. The former was (for the time) a relatively robust system of using the IDE of Win32 applications via the Windows Forms UI package, to enforce the implementation of accessibility through the ability to directly update accessibility modifiers. Even if mistakes were made, some level of usability could be leveraged with a properly designed program. However, because many use cases moved outside of the expected range of controls, and many times the applications were not even properly designed, this lead to many cases of breakdowns of accessibility in the 2000s for desktop applications, and additionally there was little motivation to enforce labeling of controls. With Flash, even though early versions of HTML offered appropriate accessibility for the era of the late 1990s, Flash offered new, dynamic and animated web user interfaces previously not available through HTML of the time, which encouraged rapid adoption across the industry, but Flash was infamously not accessible out of the box and required considerable work to be functional. This lead to a dramatic decrease in accessibility as Flash was adopted throughout the early 2000s.

In both cases we see three primary functions:

1. Restriction of developer's access to user interface solutions simply results in hacked user interface solutions to meet their demands, potentially breaking down the accessibility chain.

2. Introduction of new technologies encourages migration away from more well developed accessibility standards.

3. Even legal enforcement through fines and damages are not enough to dissuade a majority of the industry to ignore accessibility implementation expectations in interfaces if they are not already embedded into default functionality.

Thus, it can be concluded that a DOM-based approach simply repeats the same strategy that has proven to be fruitless before - restrict the developer's options and then the developer moves outside of the box. To be clear, this is not to suggest that a DOM model is not a powerful tool for accessibility in many cases. However, it cannot be asserted as a *universal* case, especially in the field of video games, where one must consider both the applications of high end video games, but also those created by individuals or teams for a small audience, such as with friends, for a Game Jam or other activities.

A critique must also be levied against enforcing accessibility on the OS layer. While I believe that accessibility services that are available through the OS should be utilized for the sake of consistency, I believe that enforcing accessibility into the OS leads to serious problems with distribution, and concerns for forming market monopolies of niche demographics. For example, while iOS is lauded for its fantastic investment in its accessibility in its mobile platform, this has lead to a measurable dominance of Apple's presence in the . While research is difficult for me to find, I found this research study in 2019 that shows that Apple has over 80% market dominance in the mobile market for blind users[^?], largely due to accessibility. This raises concerns for consumer choice in vulnerable consumer markets, such as those impacted by such large private investments in accessibility. It also raises many ethical concerns for keeping accessibility locked and embedded behind private entities - a concern that, in other parts of the accessibility market, lead to the development of open source solutions, such as NVDA (Nonvisual Desktop Assistant). Both of these lead to a restriction of consumer choice for disabled users at the cost of one private accessibility model excelling over others. Additionally, like with a DOM based approach, this leads to developers having to work under highly restrictive environments such as those seen in iOS development, and ultimately even in these restrictions are upheld by sophisticated tools, there will always be people finding a way around it, and accessibility as a subject is particularly vulnerable to this circumnavigation because of its impossibility to fully automate and its difficulty in mass testing.

While we should continue to fight for third party products to be properly accessible and legally compliant, we must also accept that this is not something that, in practice, is actually followed in many cases, even in conditions where regulations are clearer and more well established. This, with the already complex, open-ended nature of the game development field, requires a more sophisticated solution. Additionally, the concerning rise of poor-quality, questionably legal "accessibility AI guides" raises even more questions if we can continue to trust vendors to properly implement accessibility solutions. Clearly, the privatization of accessibility practices and resting responsibility solely on the producer makes implementation seriously problematic and confusing.

This begs the question of where exactly accessibility ought to be implemented if it is to be a legal requirement, something that is approaching a reality more and more every day. While I agree that some level of accessibility and communication to disabled consumers should be a requirement for popular commercial titles, it becomes more of a concern for smaller scale titles, such as indie titles. Hamilton pushes for a baseline accessibility implemented into large, popular game engines like Unreal Engine, or even OS-level accessibility. This seems like a good idea on the surface, but it raises serious concerns when details of implementation are raised. For example, if Unreal Engine implements a level of baseline accessibility for its game engine, does this predicate a potential legal precident for implementing accessibility in *all* commercially released games? What does this mean for the particular implementation practices if they are legally not allowed to be shared or used without proper licensing? If this is the case, then we must take the economic impacts of this transition very seriously, because the pressure for meeting the legal requirements of accessible games, especially from developers who are sitting on the edge of potential legal requirement thresholds, may not be feasible to those who do not wish to spend the money to pay for licenses for established solutions. This has a serious potential consequence to leverage a large sector of the gaming development sphere towards commercial game engines that require royalties to be paid in many commercial use case circumstances, thus legalizing these game engines' security in the market through the use of accessibility law, as well as potentially harming the existence of niche game engines, such as PICO8, who have no real reasonable access to standard accessibility solutions such as a DOM. Normally, such absurd levels of power would be raised with antitrust law, but because of its integration with accessibility law, this could prove to be extremely difficult - thus using a legal loophole to potentially achieve unfair market dominance. Therefore, a solution is desperately needed within the open source development community to counter these developing market conditions.

While we can never fully trust users or developers to fit neatly within the confines of a structure, in my opinion, Hamilton's proposed solutions are simply not an acceptable solution. Many indie developers do not use these kinds of game engines - for example, they may use Godot or PICO8. We should not force them to subject themselves to this level of pressure that threatens to eradicate at least part of their presence. Game developers should have the freedom of choice in game engines, including building their own, without having to be concerned with corporate and legal accessibility pressures - this extreme hostility to indie and grunge development scenes results in resistance to implementation of useful accessibility and cooperation with disabled users. This also has significant impact for disabled developers as well, who, because of limited access to funds, may want to use cheaper alternatives to well-developed highly accessible engines. Ultimately, if you do not care for the needs of the ecosystem, even a well meaning introduction to forced structure and use of particular tools will generate extreme hostility among others. Thus, it is necessary to address parts of the ecosystem that are hostile to corporate influence and involvement.

It is important to stress that the purpose of this project is not to replace any accessibility standard or expectation, but rather to make the process of implementing these standards or expectations a community-based process that is not artificially closed off by the barriers of private intellectual property rights, by integrating the broader, complex design concerns that accessibility raises in ways that open up user developer participation in the process of how their user interfaces function. In this way, encouraging a basic user modding interface allows for this modular design to be integrated into the game at a base level, allowing for alternative methods to play games to be achieved. This has many desirable traits, such as allowing users to highly customize their gaming experience, including accessibility needs that are unreasonable or difficult to standardize. Some popular games, years after release, have dedicated teams who try to improve usability and accessibility even though it requires extensive reverse engineering to locate memory addresses for functions such as text and sprite buffers, using emulators to poll these values with a script to execute accessibility functionality. This design philosophy takes the idea behind this work and simply makes it much easier for the developer by exposing these variables to modders. Furthermore, the developer is in full control through the structure of inputs and validation to limit illegal user activity, such as excess acceleration or movement range.

# Design

## Overview

I propose an alternative to the DOM/OS-rooted approach suggested by Hamilton that is more reminiscent of server-client interactions, and the benefit of this approach is that it allows for the distribution of standardized models that can be used as package baselines for developers to develop fully open-source and indie-created titles in an accessible manner. It even allows for user interfaces to be based on DOMs themselves, in the use cases where DOMs are highly optimized, such as forms and documents. In this model, I intentionally separate the game into three components - input, processing and output. This can be directly compared to a website sending a POST request, being processed by backend server processes, and the server returning its results. 

In the exposed layer, the input servlet will poll and process the state of various inputs, and transform them into a map of abstract inputs - think changing the direct values of button presses into abstract terms like movement direction. Then, in the non exposed layer, the processor sanitizes inputs to make sure they are not in illegal ranges, have illegal acceleration or correct other variation - this prevents the input servlet from inputting illegal inputs. The processor then updates the internal game state based on the state of this adjusted input structure. Finally, the processor outputs an output structure which is consumed by the output servlet, which transforms the variables into visible or audio functions.

## Advantages

The main advantages of this approach to UI design is that it will allow end users to modify an interface in any which way they please, and can potentially access a library of open-source templates to construct alternative user interfaces from through games that have documentation instructing players how to interface with the input and output variables. The Godot implementation, once implemented, is very easy to work with, and Godot itself can be used as a way to build your own interfaces easily with no special tools. However, in ideal circumstances, an open source video game engine that implements this structure from the ground up is preferred.

Notably, such a feature will allow for some level of quality of life features to be contiually implemented to the game as user interface expectations develop. This extendibility also allows for extendibility for features such as upscaling, replacing models, and other non-essential but enjoyable features.

Another feature it allows for is to allow games developed by one kind of developer to be playable by other types of players that may have complex accessibility interference. An example of this would be titles like Adventure at C or Manamon by VGStorm Games, who is a totally blind developer and cannot be reasonably expected to provide any visual feedback for his games, which may alienate deaf players. By having the UI layer exposed through variables, this is potentially no longer an issue.

Separation of the input, output and processing layers allows for clear stratification between these 3 core functionalities within the game's development. This isolates most bugs relating to input, output or processing to those three sections of the game. There are communications between the three sections, but these are managed in a controlled manner if the design theory is followed. It also helps isolate issues for debugging purposes. Allowing for open user interfaces in this manner also allows for possible new narrative and user features.

## Use Cases

The main demographic I see this appealing to the most are popular genres of indie titles that have minimal timing elements, such as visual novels, walking simulators, "cozy" games, and some roguelikes, turn-based RPGs and puzzle games. When no or minimal timing elements are involved, the game can progress in steps at its own leisure, allowing for a complete control loop between the external user I/O modules and the internal game's code.

This does not mean that games with timing based elements are excluded from finding usefulness in this process, but UIs must be more carefully prepared. This will require research into both what is necessarily being communicated by all UI components, including gameplay, as well as referring to known established examples. Some games may require more careful analysis of environmental cues to really allow for a larger open ended accessibility. I believe there is a lot of potential in this field of exploring the possibilities, but these kinds of games are not my specialty. Despite these limitations, I believe there is still value in moddability in interfaces. Historic examples outside of this engine include mods on Team Fortress 2 and other Source Engine games, allowing for the modification of user interface elements which has proven popular with gamers. It would be fairly easy to both modify existing UI components, replace them, or add new ones to help customize the gaming experience.

This high level of modularity will allow open source environments to adapt to accelerating accessibility demands, and will help continue to support these projects from potential conflict of interest from commercial game engines from using accessibility as a means to secure market territorial dominance in the game engine market. It also helps consolidate the best of two very different worlds - it allows for game developers who prefer to use more primitive draw commands and have deep control over the draw cycle to customize games the way they want while having the same variables used to display these visual effects to be available to other UI components, while also allowing for templates that use well known established standardized designs, such as that like a DOM reader or OS level tools, for applications similar to their use case needs, such as document readers or menus. Because it is not a specific technology but rather a free and open source approach to game engine development, it can be adapted by any game engine that may want to utilize its principles, or even build upon them in new ways that account for exciting new scenarios.

Another reason why Godot is not ideal for such an implementation is because the messaging system between input-processor-output is not optimized. This could possibly be improved by a C# implementation. An engine like PICO8 which intentionally has very limited memory would not be able to utilize an engine like this because it requires too much overhead (this is true for almost any accessibility structure). Instead, for PICO8, I would recommend adding accessibility BIOS calls that can add special hooks while the game is playing that allows for accessibility to be integrated into a game. This would allow at least for the development of standards, tutorials and packages that integrate these calls into the process, but I do not think an integrated solution is viable, possible or appropriate.

Of course, this all depends on the game, and Godot is not the ideal use case. My goal is to gain more support for the project and aim to develop a game engine with this design model embedded into its core design. A very useful potential set of applications could be game engines specific to a particular genre, such as implementation in visual novels or a new RPG-maker style engine, could allow for all titles created in those engines to have access to open source and community developed solutions to common accessibility problems in multiple genres.

## Potential Concerns

Some concerns may rise from this approach, some of which I will now address. One concern is the problem of responsibility of developing accessibility. It is inherently better for games to be developed with accessibility in mind than without, and transitioning the responsibility to the community may lead to gaps in development, or cause developers to assume the responsibility does not necessarily lie on them. It is therefore important to educate people that modding-as-accessibility is intended to complement currently existing techniques, and to allow for open source initiatives to have better access and flow between design practices, **not as a replacement for any currently existing accessibility model**. It is important to emphasize that, like with any other structural accessibility approach, that engagement with the developer is necessary on all steps, and that opening contribution to the userbase does not excuse the lack of implementation of accessibility. With that being said, this approach does aim to improve resources available in open source spaces for accessibility models. Again, modding-as-accessibility does not exist to replace currently existing accessibility techniques, only to make it easier for users of such applications to be able to make their own custom solutions.

Another concern is how such an open-ended, modular design could impact some games. Having different kinds of user interfaces could lead to balancing issues for online games. While input validation can limit some behaviors, it may still be tricky to manage in multiplayer settings. This problem should be explored with people who are experienced in multiplayer game implementation - however, because of client-server behavior, there is likely already infrastructure that supports this kind of separation of processing already.

An additional concern is that of security - running external, unvetted software does pose the risk of malicious execution of code. To avoid this issue, it should be communicated very clearly to the end user that any modifications with unvetted code could potentially pose a security risk. Some implementations could whitelist functions and ignore functions not within the whitelist, which would disable otherwise unnecessary functions such as internet connection, file I/O or other malicious activity.

This solution is not ideal for applications that intend to monetize UI elements, or applications that intend to use aggressively strict UI design to direct players in highly specific ways, such as those seen in predatory gambling or microtransaction titles. However, it is ideal for small, single player titles usually made by indie developers.

# Implementation and Demonstration

## Specifications

This prototype was developed in Godot 4.5. Godot was selected because it has full support for 3D rendered environments and collisions out of the box, supports dynamically loading asset files (.PCK), is free and open source, and has recently been integrated with AccessKit integration. Ideally, such an engine would be built from the ground up to integrate this behavior much more deeply into the management workflow, but for demonstration purposes, Godot is sufficient. Godot will probably also be used for a future project using this system as a proof-of-concept design. However, in the long term, Godot should be retired and a new engine should be developed, since Godot is not optimized for separating input/output from processing, and has other systemic issues with the engine that make it not ideal for extended projects like these.

### Smash the Creeps Demo

Note: *This demo is not intended as a demonstration of accessibility,* only a demonstration of swapping user interfaces.

Note: All files for this section are located in ``games/assets/smash_creeps``.

[Demo Repository]()

[Squash the Creeps](https://godotengine.org/asset-library/asset/2751) is a Demo game project provided by Godot to demonstrate the basic features of the engine. It features a small creature smashing on creeps by navigating the map and jumping on them. The player accumulates a score until they are hit by one of the creeps, which opens a retry screen. This proof of concept is intended to demonstrate the basic potential of using a modular deisgn with emphasis on separation of user I/O layer from the game's processing layer.

The original Smash the Creeps demo is designed with no separation between user I/O and game logic. In fact, this appears to be the assumption under which Godot was designed. For example, the player and mob objects both contain code for any relevant inputs, have the objects containing their meshes, and so on. This means that in order to convert the game, I had to split these components from the object and separate them. I detail the implementation process below.

#### Initial Implemetation

I started by constructing the game object loader. For this game, there is no need for any advanced features, so it simply loads games and its input/output modules. This file is located at ``res://engine/core/game.gd`` and ``res://engine/core/GameComponent.tscn``. In the scene file, I have three nodes:

```
- Input
- Process
- Output
```

These are primarily used for organizational purposes. Input's processing is disabled, but Process and Output's processing must be enabled for game functionality to work. The scene is saved as a Global with the name GameComponent so that it can be accessed throughout the application

Every ``_process()`` frame, the input is polled, the game is procssed and the output state is set.

The object also has the ability to set input variables, and to get/set output variables. This way input/output scripts can access this global operator without passing a variable around. Plus, these values should just be available at all times anyways.

Note: The implementation of these getter/setter methods is not optimal. Godot also makes it difficult to restrict access to members, so all variables are effectively public.

For the game files, first I created the ``Input.tscn`` and ``Output.tscn`` files, which represent the default input and output modules. When the game is first loaded, if there is no overriding .PCK mod file, it will use the default input/output (thus still contained within the default project). Additionally, I modified ``Main.tscn`` to include variables for the default input and output modules, as well as the name of the mod file it looks for.

With this in place, I started with input, because input is relatively easy to consolidate. All the input script does is when ``do_process()`` is called by the ``GameController`` every process step, polls inputs and returns their results to the game. The input map has the following structure, with its default values:

```
movement: Vector3.ZERO
retry: false
jump: false
```

Notice that this is not simply just polling for the state of the inputs, but the interface represents an abstraction of what input should ultimately be interpreted as. In this case, ``movement`` consolidates the keypad buttons as a single movement variable, since they are all used for basic movement. This interface makes it easier to implement other input models, which will be demonstrated below.

After the input module polls the state of the inputs and outputs its state, the state is validated to ensure that the input stays within appropriate limits and acceleration. This helps prevent cheating behaviors. Currently, this only normalizes the Vector3 input to ensure that it stays within range.

Processing then occurs primarily within Main.tscn/Main.gd in the function ``do_process``, which is called by the controller at this time. This function sets various internal values relevant to the game state, similar to ``_process()`` in a normal Godot game. ``_process()`` is not used because more granular control is required for when exactly processing occurs.

One limitation discovered while implementing was recognizing how Godot's physics processing interferes with assumptions about the availability of variables, leading to difficulties in maintaining the assumptions of the communication machine between processor and output. This would lead to incorrect displays. Godot splits the physics and idle processing into two different processing flows which run at slightly different rates (physics is intended to run exactly 60 frames per second while idle is variable and occupies idle time between frames). This was resolved by isolating all output updates into the ``do_process`` routine, and using physics to only update the internal location states. In addition, to prevent conflicts from calling signals in the physics process cycle, flags are set that trigger the actions on the next ``do_process`` call instead to make sure all communication updates are contained within ``do_process``.

While processing, values can be set for output export by setting them with ``GameController.set_output()``. It turned out that while developing, I underestimated the amount of modifications needed to the output dictionary that my visible public interface was limited in expressing (while in Godot you can call private variables and functions that start with ``_`` but these are considered private functions and it is considered bad practice to do so). In future implementations I will make the interface more open for output generation.

The output dictionary model has the following structure:

```
player:
    position: Vector3.ZERO
    rotation: Vector3.ZERO 
    moving: false
    air: false

mobs:
    mob1:
        position: Vector3.ZERO
        rotation: Vector3.ZERO
        speed: 1
    [...]
```

Essentially, the output includes data about the player position and attributes, and a list of all active mobs. This data is processed by the output module. This module is what manipulates the meshes to actually make the output visible. It simply updates the player position, but mobs are more involved. For each mob, it will be assigned an identifier based on its ID in the dictionary model. If the mob does not exist, it will create one. If a mob is to be deleted, it will have an empty data struture instead, which signifies to the output module to delete the mob object.

With this system, the visual components of the game are all isolated from the internal processing, which exposes the game's processor component with input and output variables on its surface, allowing for direct manipulation of the game state on this interface, which we will explore in the following section.

Finally, Squash the Creeps has a scene reset functionality. Unfortunately, because of the use of the control node as the base root node, this leads to the game being unable to use the default reset scene functionality. Instead, it just frees the current scene quickly while replacing it with a new one. 

#### Implementation of External Input Modules

Sources:

[^?]: [Exploring the use of smartphones and tablets among people with visual impairments: Are mainstream devices replacing the use of traditional visual aids?](https://www.tandfonline.com/doi/full/10.1080/10400435.2019.1682084#d1e458)
